# -*- coding: utf-8 -*-
"""task_1b.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FW7Tvl5Zdj-ij_NNELlwO-fJ0R-rAilU
"""

#task1_B
from collections import defaultdict

input_data = open("input1b.txt","r")
output_data = open("output1b.txt","w")
n,m = map(int,input_data.readline().split())

def buildgraph(edges):
  graph = defaultdict(list)
  for u,v in edges:
    graph[u].append(v)
  return graph

def bfs(graph):
  visited = []
  queue = list(graph.keys())
  path = []
  while queue:
    vertex = queue.pop(0)
    if vertex not in visited:
      visited.append(vertex)
      path.append(vertex)
      for neighbor in graph[vertex]:
          queue.append(neighbor)
  return path

def cycle(graph, s, visited = None, recstack = None):
  if visited is None:
    visited = set()
  if recstack is None:
    recstack = set()
  visited.add(s)
  recstack.add(s)

  for nrbgh in graph[s]:
    if nrbgh not in visited:
      z = cycle(graph,nrbgh,visited,recstack)
      if z:
        return True
    elif nrbgh in recstack:
      return True
  recstack.remove(s)
  return False

edges = [tuple(map(int,input_data.readline().split())) for i in range(m)]
graph = buildgraph(edges)
find_search = bfs(graph)
resultdata =  any(cycle(graph, node) for node in range(1, n + 1))

if not resultdata:
  print(*find_search, file = output_data)
else:
  print("IMPOSSIBLE", file = output_data)

output_data.close()