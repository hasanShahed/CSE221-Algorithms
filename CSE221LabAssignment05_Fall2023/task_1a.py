# -*- coding: utf-8 -*-
"""task_1b.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FW7Tvl5Zdj-ij_NNELlwO-fJ0R-rAilU
"""

#task1_A

from collections import defaultdict
input_data = open("input1a.txt","r")
output_data = open("output1a.txt","w")
n,m = map(int,input_data.readline().split())

def buildgraph(edges):
  graph = defaultdict(list)
  for u,v in edges:
    graph[u].append(v)
  return graph

def dfs(graph, node, visited, stack):
  visited[node] = True
  for next_node in graph[node]:
    if not visited[next_node]:
      dfs(graph, next_node, visited, stack)
  stack.append(node)

def cycle(graph, s, visited = None, recstack = None):
  if visited is None:
    visited = set()
  if recstack is None:
    recstack = set()
  visited.add(s)
  recstack.add(s)

  for nrbgh in graph[s]:
    if nrbgh not in visited:
      z= cycle(graph,nrbgh,visited,recstack)
      if z:
        return True
    elif nrbgh in recstack:
      return True
  recstack.remove(s)
  return False

def find_order(graph, n):
  visited = [False] * (n + 1)
  stack = []

  for node in range(1, n + 1):
    if not visited[node]:
      dfs(graph, node, visited, stack)
  return stack[::-1]

edges = [tuple(map(int,input_data.readline().split())) for i in range(m)]
graph = buildgraph(edges)
find_search = find_order(graph,n)
resultdata = any(cycle(graph, node) for node in range(1, n + 1))

if not resultdata:
  print(*find_search, file = output_data)
else:
  print("IMPOSSIBLE", file = output_data)

output_data.close()